{
  "test/index.js": {
    "id": "test/index.js",
    "type": "js",
    "mtime": 1409536493000,
    "src": "/**\n * Module Dependencies\n */\n\nvar support = require('generator-support');\nvar assert = require('assert');\nvar wrap = require('..');\n\n/**\n * Tests\n */\n\ndescribe('wrap-fn', function() {\n\n  describe('noop', function() {\n    it('should work if fn is undefined', function(done) {\n\n      function next(err, a, b) {\n        assert(this.ctx = 'ctx');\n        assert('a' == a);\n        assert('b' == b);\n        assert(!err);\n        done();\n      }\n\n      wrap(null, next).call({ ctx: 'ctx'}, 'a', 'b');\n    })\n  })\n\n  describe('sync', function() {\n    it('should pass args and preserve context', function(done) {\n      var called = 0;\n\n      function sync(a, b) {\n        assert(this.ctx = 'ctx');\n        assert('a' == a);\n        assert('b' == b);\n        called++;\n      }\n\n      function next(err) {\n        assert(called);\n        assert(!err);\n        done();\n      }\n\n      wrap(sync, next).call({ ctx: 'ctx' }, 'a', 'b')\n    });\n\n    it('handle errors', function(done) {\n      var called = 0;\n\n      function sync(a, b) {\n        called++;\n        assert(this.ctx = 'ctx');\n        assert('a' == a);\n        assert('b' == b);\n\n        return new Error('some error');\n      }\n\n      function next(err) {\n        assert(err);\n        assert(called);\n        assert('some error' == err.message);\n        done();\n      }\n\n      wrap(sync, next).call({ ctx: 'ctx' }, 'a', 'b')\n    });\n  })\n\n  describe('async', function(done) {\n    it('should pass args and preserve context', function(done) {\n      var called = 0;\n\n      function sync(a, b, fn) {\n        assert(this.ctx = 'ctx');\n        assert('a' == a);\n        assert('b' == b);\n        called++;\n        fn(null, a, b)\n      }\n\n      function next(err, a, b) {\n        assert(!err);\n        assert(called);\n        assert('a' == a);\n        assert('b' == b);\n        done();\n      }\n\n      wrap(sync, next).call({ ctx: 'ctx' }, 'a', 'b')\n    });\n\n    it('handle errors', function(done) {\n      var called = 0;\n\n      function sync(a, b, fn) {\n        called++;\n        assert(this.ctx = 'ctx');\n        assert('a' == a);\n        assert('b' == b);\n        fn(new Error('some error'));\n      }\n\n      function next(err, a, b) {\n        assert(err);\n        assert(called);\n        assert('some error' == err.message);\n        done();\n      }\n\n      wrap(sync, next).call({ ctx: 'ctx' }, 'a', 'b')\n    });\n  })\n\n  // describe('generator', function() {\n  //   it('should pass args and preserve context', function(done) {\n  //     var called = 0;\n\n  //     function *gen(a, b) {\n  //       assert(this.ctx = 'ctx');\n  //       assert('a' == a);\n  //       assert('b' == b);\n  //       yield wait(100);\n  //       called++;\n  //       return a;\n  //     }\n\n  //     function next(err, a) {\n  //       assert(!err);\n  //       assert(called);\n  //       assert('a' == a);\n  //       done();\n  //     }\n\n  //     wrap(gen, next).call({ ctx: 'ctx' }, 'a', 'b')\n  //   });\n\n  //   it('handle errors', function(done) {\n  //     var called = 0;\n\n  //     function *gen(a, b) {\n  //       called++;\n  //       assert(this.ctx = 'ctx');\n  //       assert('a' == a);\n  //       assert('b' == b);\n  //       throw new Error('some error');\n  //       return a;\n  //     }\n\n  //     function next(err, a) {\n  //       assert(!a);\n  //       assert(err);\n  //       assert(called);\n  //       assert('some error' == err.message);\n  //       done();\n  //     }\n\n  //     wrap(gen, next).call({ ctx: 'ctx' }, 'a', 'b')\n  //   });\n  // })\n\n});\n\nfunction wait(ms) {\n  return function(fn) {\n    setTimeout(fn, ms);\n  }\n}\n\n\n",
    "deps": {
      "generator-support": "components/matthewmueller-generator-support@0.0.1/index.js",
      "assert": "components/component-assert@0.4.0/index.js",
      "..": "index.js"
    },
    "entry": true
  },
  "index.js": {
    "id": "index.js",
    "type": "js",
    "mtime": 1409534363000,
    "src": "/**\n * Module Dependencies\n */\n\nvar slice = [].slice;\nvar co = require('co');\nvar noop = function(){};\n\n/**\n * Export `wrap-fn`\n */\n\nmodule.exports = wrap;\n\n/**\n * Wrap a function to support\n * sync, async, and gen functions.\n *\n * @param {Function} fn\n * @param {Function} done\n * @return {Function}\n * @api public\n */\n\nfunction wrap(fn, done) {\n  done = done || noop;\n\n  return function() {\n    var args = slice.call(arguments);\n    var ctx = this;\n\n    if (!fn) {\n      // done\n      return done.apply(ctx, [null].concat(args));\n    } else if (fn.length > args.length) {\n      // async\n      fn.apply(ctx, args.concat(done));\n    } else if (generator(fn)) {\n      // generator\n      co(fn).apply(ctx, args.concat(done));\n    } else {\n      // sync\n      var ret = fn.apply(ctx, args);\n      ret instanceof Error ? done(ret) : done();\n    }\n  }\n}\n\n/**\n * Is `value` a generator?\n *\n * @param {Mixed} value\n * @return {Boolean}\n * @api private\n */\n\nfunction generator(value) {\n  return value\n    && value.constructor\n    && 'GeneratorFunction' == value.constructor.name;\n}\n",
    "deps": {
      "co": "components/visionmedia-co@3.1.0/index.js"
    }
  },
  "components/visionmedia-co@3.1.0/index.js": {
    "id": "components/visionmedia-co@3.1.0/index.js",
    "type": "js",
    "mtime": 1404182887000,
    "src": "\n/**\n * slice() reference.\n */\n\nvar slice = Array.prototype.slice;\n\n/**\n * Expose `co`.\n */\n\nmodule.exports = co;\n\n/**\n * Wrap the given generator `fn` and\n * return a thunk.\n *\n * @param {Function} fn\n * @return {Function}\n * @api public\n */\n\nfunction co(fn) {\n  var isGenFun = isGeneratorFunction(fn);\n\n  return function (done) {\n    var ctx = this;\n\n    // in toThunk() below we invoke co()\n    // with a generator, so optimize for\n    // this case\n    var gen = fn;\n\n    // we only need to parse the arguments\n    // if gen is a generator function.\n    if (isGenFun) {\n      var args = slice.call(arguments), len = args.length;\n      var hasCallback = len && 'function' == typeof args[len - 1];\n      done = hasCallback ? args.pop() : error;\n      gen = fn.apply(this, args);\n    } else {\n      done = done || error;\n    }\n\n    next();\n\n    // #92\n    // wrap the callback in a setImmediate\n    // so that any of its errors aren't caught by `co`\n    function exit(err, res) {\n      setImmediate(function(){\n        done.call(ctx, err, res);\n      });\n    }\n\n    function next(err, res) {\n      var ret;\n\n      // multiple args\n      if (arguments.length > 2) res = slice.call(arguments, 1);\n\n      // error\n      if (err) {\n        try {\n          ret = gen.throw(err);\n        } catch (e) {\n          return exit(e);\n        }\n      }\n\n      // ok\n      if (!err) {\n        try {\n          ret = gen.next(res);\n        } catch (e) {\n          return exit(e);\n        }\n      }\n\n      // done\n      if (ret.done) return exit(null, ret.value);\n\n      // normalize\n      ret.value = toThunk(ret.value, ctx);\n\n      // run\n      if ('function' == typeof ret.value) {\n        var called = false;\n        try {\n          ret.value.call(ctx, function(){\n            if (called) return;\n            called = true;\n            next.apply(ctx, arguments);\n          });\n        } catch (e) {\n          setImmediate(function(){\n            if (called) return;\n            called = true;\n            next(e);\n          });\n        }\n        return;\n      }\n\n      // invalid\n      next(new TypeError('You may only yield a function, promise, generator, array, or object, '\n        + 'but the following was passed: \"' + String(ret.value) + '\"'));\n    }\n  }\n}\n\n/**\n * Convert `obj` into a normalized thunk.\n *\n * @param {Mixed} obj\n * @param {Mixed} ctx\n * @return {Function}\n * @api private\n */\n\nfunction toThunk(obj, ctx) {\n\n  if (isGeneratorFunction(obj)) {\n    return co(obj.call(ctx));\n  }\n\n  if (isGenerator(obj)) {\n    return co(obj);\n  }\n\n  if (isPromise(obj)) {\n    return promiseToThunk(obj);\n  }\n\n  if ('function' == typeof obj) {\n    return obj;\n  }\n\n  if (isObject(obj) || Array.isArray(obj)) {\n    return objectToThunk.call(ctx, obj);\n  }\n\n  return obj;\n}\n\n/**\n * Convert an object of yieldables to a thunk.\n *\n * @param {Object} obj\n * @return {Function}\n * @api private\n */\n\nfunction objectToThunk(obj){\n  var ctx = this;\n  var isArray = Array.isArray(obj);\n\n  return function(done){\n    var keys = Object.keys(obj);\n    var pending = keys.length;\n    var results = isArray\n      ? new Array(pending) // predefine the array length\n      : new obj.constructor();\n    var finished;\n\n    if (!pending) {\n      setImmediate(function(){\n        done(null, results)\n      });\n      return;\n    }\n\n    // prepopulate object keys to preserve key ordering\n    if (!isArray) {\n      for (var i = 0; i < pending; i++) {\n        results[keys[i]] = undefined;\n      }\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      run(obj[keys[i]], keys[i]);\n    }\n\n    function run(fn, key) {\n      if (finished) return;\n      try {\n        fn = toThunk(fn, ctx);\n\n        if ('function' != typeof fn) {\n          results[key] = fn;\n          return --pending || done(null, results);\n        }\n\n        fn.call(ctx, function(err, res){\n          if (finished) return;\n\n          if (err) {\n            finished = true;\n            return done(err);\n          }\n\n          results[key] = res;\n          --pending || done(null, results);\n        });\n      } catch (err) {\n        finished = true;\n        done(err);\n      }\n    }\n  }\n}\n\n/**\n * Convert `promise` to a thunk.\n *\n * @param {Object} promise\n * @return {Function}\n * @api private\n */\n\nfunction promiseToThunk(promise) {\n  return function(fn){\n    promise.then(function(res) {\n      fn(null, res);\n    }, fn);\n  }\n}\n\n/**\n * Check if `obj` is a promise.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isPromise(obj) {\n  return obj && 'function' == typeof obj.then;\n}\n\n/**\n * Check if `obj` is a generator.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isGenerator(obj) {\n  return obj && 'function' == typeof obj.next && 'function' == typeof obj.throw;\n}\n\n/**\n * Check if `obj` is a generator function.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isGeneratorFunction(obj) {\n  return obj && obj.constructor && 'GeneratorFunction' == obj.constructor.name;\n}\n\n/**\n * Check for plain object.\n *\n * @param {Mixed} val\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(val) {\n  return val && Object == val.constructor;\n}\n\n/**\n * Throw `err` in a new stack.\n *\n * This is used when co() is invoked\n * without supplying a callback, which\n * should only be for demonstrational\n * purposes.\n *\n * @param {Error} err\n * @api private\n */\n\nfunction error(err) {\n  if (!err) return;\n  setImmediate(function(){\n    throw err;\n  });\n}\n",
    "deps": {}
  },
  "components/matthewmueller-generator-support@0.0.1/index.js": {
    "id": "components/matthewmueller-generator-support@0.0.1/index.js",
    "type": "js",
    "mtime": 1409533749000,
    "src": "try {\n  eval('(function* () {})()');\n  module.exports = true;\n} catch (e) {\n  module.exports = false;\n}\n",
    "deps": {}
  },
  "components/component-assert@0.4.0/index.js": {
    "id": "components/component-assert@0.4.0/index.js",
    "type": "js",
    "mtime": 1404177283000,
    "src": "\n/**\n * Module dependencies.\n */\n\nvar equals = require('equals');\nvar fmt = require('fmt');\nvar stack = require('stack');\n\n/**\n * Assert `expr` with optional failure `msg`.\n *\n * @param {Mixed} expr\n * @param {String} [msg]\n * @api public\n */\n\nmodule.exports = exports = function (expr, msg) {\n  if (expr) return;\n  throw new Error(msg || message());\n};\n\n/**\n * Assert `actual` is weak equal to `expected`.\n *\n * @param {Mixed} actual\n * @param {Mixed} expected\n * @param {String} [msg]\n * @api public\n */\n\nexports.equal = function (actual, expected, msg) {\n  if (actual == expected) return;\n  throw new Error(msg || fmt('Expected %o to equal %o.', actual, expected));\n};\n\n/**\n * Assert `actual` is not weak equal to `expected`.\n *\n * @param {Mixed} actual\n * @param {Mixed} expected\n * @param {String} [msg]\n * @api public\n */\n\nexports.notEqual = function (actual, expected, msg) {\n  if (actual != expected) return;\n  throw new Error(msg || fmt('Expected %o not to equal %o.', actual, expected));\n};\n\n/**\n * Assert `actual` is deep equal to `expected`.\n *\n * @param {Mixed} actual\n * @param {Mixed} expected\n * @param {String} [msg]\n * @api public\n */\n\nexports.deepEqual = function (actual, expected, msg) {\n  if (equals(actual, expected)) return;\n  throw new Error(msg || fmt('Expected %o to deeply equal %o.', actual, expected));\n};\n\n/**\n * Assert `actual` is not deep equal to `expected`.\n *\n * @param {Mixed} actual\n * @param {Mixed} expected\n * @param {String} [msg]\n * @api public\n */\n\nexports.notDeepEqual = function (actual, expected, msg) {\n  if (!equals(actual, expected)) return;\n  throw new Error(msg || fmt('Expected %o not to deeply equal %o.', actual, expected));\n};\n\n/**\n * Assert `actual` is strict equal to `expected`.\n *\n * @param {Mixed} actual\n * @param {Mixed} expected\n * @param {String} [msg]\n * @api public\n */\n\nexports.strictEqual = function (actual, expected, msg) {\n  if (actual === expected) return;\n  throw new Error(msg || fmt('Expected %o to strictly equal %o.', actual, expected));\n};\n\n/**\n * Assert `actual` is not strict equal to `expected`.\n *\n * @param {Mixed} actual\n * @param {Mixed} expected\n * @param {String} [msg]\n * @api public\n */\n\nexports.notStrictEqual = function (actual, expected, msg) {\n  if (actual !== expected) return;\n  throw new Error(msg || fmt('Expected %o not to strictly equal %o.', actual, expected));\n};\n\n/**\n * Assert `block` throws an `error`.\n *\n * @param {Function} block\n * @param {Function} [error]\n * @param {String} [msg]\n * @api public\n */\n\nexports.throws = function (block, error, msg) {\n  var err;\n  try {\n    block();\n  } catch (e) {\n    err = e;\n  }\n\n  if (!err) throw new Error(msg || fmt('Expected %s to throw an error.', block.toString()));\n  if (error && !(err instanceof error)) {\n    throw new Error(msg || fmt('Expected %s to throw an %o.', block.toString(), error));\n  }\n};\n\n/**\n * Assert `block` doesn't throw an `error`.\n *\n * @param {Function} block\n * @param {Function} [error]\n * @param {String} [msg]\n * @api public\n */\n\nexports.doesNotThrow = function (block, error, msg) {\n  var err;\n  try {\n    block();\n  } catch (e) {\n    err = e;\n  }\n\n  if (err) throw new Error(msg || fmt('Expected %s not to throw an error.', block.toString()));\n  if (error && (err instanceof error)) {\n    throw new Error(msg || fmt('Expected %s not to throw an %o.', block.toString(), error));\n  }\n};\n\n/**\n * Create a message from the call stack.\n *\n * @return {String}\n * @api private\n */\n\nfunction message() {\n  if (!Error.captureStackTrace) return 'assertion failed';\n  var callsite = stack()[2];\n  var fn = callsite.getFunctionName();\n  var file = callsite.getFileName();\n  var line = callsite.getLineNumber() - 1;\n  var col = callsite.getColumnNumber() - 1;\n  var src = get(file);\n  line = src.split('\\n')[line].slice(col);\n  var m = line.match(/assert\\((.*)\\)/);\n  return m && m[1].trim();\n}\n\n/**\n * Load contents of `script`.\n *\n * @param {String} script\n * @return {String}\n * @api private\n */\n\nfunction get(script) {\n  var xhr = new XMLHttpRequest;\n  xhr.open('GET', script, false);\n  xhr.send(null);\n  return xhr.responseText;\n}\n",
    "deps": {
      "equals": "components/jkroso-equals@0.3.6/index.js",
      "fmt": "components/yields-fmt@0.0.2/index.js",
      "stack": "components/component-stack@0.0.1/index.js"
    }
  },
  "components/yields-fmt@0.0.2/index.js": {
    "id": "components/yields-fmt@0.0.2/index.js",
    "type": "js",
    "mtime": 1386714383000,
    "src": "\n/**\n * Export `fmt`\n */\n\nmodule.exports = fmt;\n\n/**\n * Formatters\n */\n\nfmt.o = JSON.stringify;\nfmt.s = String;\nfmt.d = parseInt;\n\n/**\n * Format the given `str`.\n *\n * @param {String} str\n * @param {...} args\n * @return {String}\n * @api public\n */\n\nfunction fmt(str){\n  var args = [].slice.call(arguments, 1);\n  var j = 0;\n\n  return str.replace(/%([a-z])/gi, function(_, f){\n    return fmt[f]\n      ? fmt[f](args[j++])\n      : _ + f;\n  });\n}\n",
    "deps": {}
  },
  "components/component-stack@0.0.1/index.js": {
    "id": "components/component-stack@0.0.1/index.js",
    "type": "js",
    "mtime": 1349846180000,
    "src": "\n/**\n * Expose `stack()`.\n */\n\nmodule.exports = stack;\n\n/**\n * Return the stack.\n *\n * @return {Array}\n * @api public\n */\n\nfunction stack() {\n  var orig = Error.prepareStackTrace;\n  Error.prepareStackTrace = function(_, stack){ return stack; };\n  var err = new Error;\n  Error.captureStackTrace(err, arguments.callee);\n  var stack = err.stack;\n  Error.prepareStackTrace = orig;\n  return stack;\n}",
    "deps": {}
  },
  "components/jkroso-equals@0.3.6/index.js": {
    "id": "components/jkroso-equals@0.3.6/index.js",
    "type": "js",
    "mtime": 1392871768000,
    "src": "\nvar type = require('type')\n\n/**\n * expose equals\n */\n\nmodule.exports = equals\nequals.compare = compare\n\n/**\n * assert all values are equal\n *\n * @param {Any} [...]\n * @return {Boolean}\n */\n\n function equals(){\n  var i = arguments.length - 1\n  while (i > 0) {\n    if (!compare(arguments[i], arguments[--i])) return false\n  }\n  return true\n}\n\n// (any, any, [array]) -> boolean\nfunction compare(a, b, memos){\n  // All identical values are equivalent\n  if (a === b) return true\n  var fnA = types[type(a)]\n  var fnB = types[type(b)]\n  return fnA && fnA === fnB\n    ? fnA(a, b, memos)\n    : false\n}\n\nvar types = {}\n\n// (Number) -> boolean\ntypes.number = function(a){\n  // NaN check\n  return a !== a\n}\n\n// (function, function, array) -> boolean\ntypes['function'] = function(a, b, memos){\n  return a.toString() === b.toString()\n    // Functions can act as objects\n    && types.object(a, b, memos)\n    && compare(a.prototype, b.prototype)\n}\n\n// (date, date) -> boolean\ntypes.date = function(a, b){\n  return +a === +b\n}\n\n// (regexp, regexp) -> boolean\ntypes.regexp = function(a, b){\n  return a.toString() === b.toString()\n}\n\n// (DOMElement, DOMElement) -> boolean\ntypes.element = function(a, b){\n  return a.outerHTML === b.outerHTML\n}\n\n// (textnode, textnode) -> boolean\ntypes.textnode = function(a, b){\n  return a.textContent === b.textContent\n}\n\n// decorate `fn` to prevent it re-checking objects\n// (function) -> function\nfunction memoGaurd(fn){\n  return function(a, b, memos){\n    if (!memos) return fn(a, b, [])\n    var i = memos.length, memo\n    while (memo = memos[--i]) {\n      if (memo[0] === a && memo[1] === b) return true\n    }\n    return fn(a, b, memos)\n  }\n}\n\ntypes['arguments'] =\ntypes.array = memoGaurd(compareArrays)\n\n// (array, array, array) -> boolean\nfunction compareArrays(a, b, memos){\n  var i = a.length\n  if (i !== b.length) return false\n  memos.push([a, b])\n  while (i--) {\n    if (!compare(a[i], b[i], memos)) return false\n  }\n  return true\n}\n\ntypes.object = memoGaurd(compareObjects)\n\n// (object, object, array) -> boolean\nfunction compareObjects(a, b, memos) {\n  var ka = getEnumerableProperties(a)\n  var kb = getEnumerableProperties(b)\n  var i = ka.length\n\n  // same number of properties\n  if (i !== kb.length) return false\n\n  // although not necessarily the same order\n  ka.sort()\n  kb.sort()\n\n  // cheap key test\n  while (i--) if (ka[i] !== kb[i]) return false\n\n  // remember\n  memos.push([a, b])\n\n  // iterate again this time doing a thorough check\n  i = ka.length\n  while (i--) {\n    var key = ka[i]\n    if (!compare(a[key], b[key], memos)) return false\n  }\n\n  return true\n}\n\n// (object) -> array\nfunction getEnumerableProperties (object) {\n  var result = []\n  for (var k in object) if (k !== 'constructor') {\n    result.push(k)\n  }\n  return result\n}\n",
    "deps": {
      "type": "components/jkroso-type@1.1.0/index.js"
    }
  },
  "components/jkroso-type@1.1.0/index.js": {
    "id": "components/jkroso-type@1.1.0/index.js",
    "type": "js",
    "mtime": 1392871670000,
    "src": "\nvar toString = {}.toString\nvar DomNode = typeof window != 'undefined'\n  ? window.Node\n  : Function\n\n/**\n * Return the type of `val`.\n *\n * @param {Mixed} val\n * @return {String}\n * @api public\n */\n\nmodule.exports = exports = function(x){\n  var type = typeof x\n  if (type != 'object') return type\n  type = types[toString.call(x)]\n  if (type) return type\n  if (x instanceof DomNode) switch (x.nodeType) {\n    case 1:  return 'element'\n    case 3:  return 'text-node'\n    case 9:  return 'document'\n    case 11: return 'document-fragment'\n    default: return 'dom-node'\n  }\n}\n\nvar types = exports.types = {\n  '[object Function]': 'function',\n  '[object Date]': 'date',\n  '[object RegExp]': 'regexp',\n  '[object Arguments]': 'arguments',\n  '[object Array]': 'array',\n  '[object String]': 'string',\n  '[object Null]': 'null',\n  '[object Undefined]': 'undefined',\n  '[object Number]': 'number',\n  '[object Boolean]': 'boolean',\n  '[object Object]': 'object',\n  '[object Text]': 'text-node',\n  '[object Uint8Array]': 'bit-array',\n  '[object Uint16Array]': 'bit-array',\n  '[object Uint32Array]': 'bit-array',\n  '[object Uint8ClampedArray]': 'bit-array',\n  '[object Error]': 'error',\n  '[object FormData]': 'form-data',\n  '[object File]': 'file',\n  '[object Blob]': 'blob'\n}\n",
    "deps": {}
  }
}